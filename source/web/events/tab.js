import {paragraphTag} from "../common-tags.js";
import {getRangeIfInside} from "../cursor.js";
import {getParentWithOffset} from "../offsets.js";
import {findCorrection} from "../input-handler.js";

const initialButtonClassName = 'input-initial-button';

export function attachTabEvent(container, settingCheckboxes) {
  container.addEventListener('keydown', (event) => {
    if (event.code !== 'Tab' || event.target !== container) { // We are not interested in events generated by
      return;                                                 // interaction with tooltips
    }
    const range = getRangeIfInside(container);
    if (range === null) {
      return;
    }
    const ahead = !event.shiftKey;
    const focusOutside = () => {
      if (!ahead || settingCheckboxes.length === 0) { // settingCheckboxes should always be nonempty
        return; // Shift + Tab should work properly as is
      }
      event.preventDefault(); // Otherwise, we need to prevent focusing on the first correction
      settingCheckboxes[0].focus();
    };
    const focusOnButton = (button) => {
      event.preventDefault();
      button.focus();
    };
    const focusOnButtonsOrOutside = () => {
      const initialButton = container.querySelector(`.${initialButtonClassName}`);
      if (initialButton === null) {
        focusOutside();
      } else {
        focusOnButton(initialButton);
      }
    };
    const [node, nodeOffset] = ahead
      ? [range.startContainer, range.startOffset] // We want to cover the tokens inside the selection as well
      : [range.endContainer, range.endOffset];
    let paragraph, offset;
    if (node === container) { // Cursor is between two paragraphs; happens at least in Firefox
      const childIndex = ahead ? nodeOffset : nodeOffset - 1;
      if (childIndex < 0 || childIndex >= container.childNodes.length) {
        return focusOnButtonsOrOutside();
      }
      paragraph = container.childNodes[childIndex];
      offset = null;
    } else {
      ({parent: paragraph, offset} = getParentWithOffset(
        (node) => node.nodeType === Node.ELEMENT_NODE && node.tagName === paragraphTag,
        node, nodeOffset
      ));
    }
    const correction = findCorrection(paragraph, ({start, end}, currentParagraph) => {
      return offset === null || currentParagraph !== paragraph || (ahead && end > offset) || (!ahead && start < offset);
    }, ahead);
    if (correction === null) {
      return focusOnButtonsOrOutside();
    }
    event.preventDefault();
    setTimeout(() => correction.element.focus(), 0); // Otherwise the tooltip closes as effect of the same keydown event
  });
}